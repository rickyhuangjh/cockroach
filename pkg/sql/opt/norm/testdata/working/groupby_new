exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    i INT NOT NULL,
    f FLOAT,
    s STRING NOT NULL,
    j JSON,
    UNIQUE INDEX si_idx (s DESC, i) STORING (j),
    UNIQUE INDEX fi_idx (f, i)
)
----

exec-ddl
CREATE TABLE xy
(
    x INT PRIMARY KEY,
    y INT
)
----

exec-ddl
CREATE TABLE fks
(
    k INT PRIMARY KEY,
    v INT,
    r0 INT NOT NULL REFERENCES xy(x),
    r1 INT REFERENCES xy(x)
)
----

exec-ddl
CREATE TABLE abc
(
    a INT,
    b INT,
    c INT,
    PRIMARY KEY (a,b,c)
)
----

exec-ddl
CREATE TABLE uvwz
(
    u INT NOT NULL,
    v INT NOT NULL,
    w INT NOT NULL,
    z INT NOT NULL,

    UNIQUE INDEX (u,v),
    UNIQUE INDEX (v,w)
)
----

exec-ddl
CREATE TABLE s (
    s STRING PRIMARY KEY
)
----

exec-ddl
CREATE TABLE nullablecols (
    c1 INT,
    c2 INT,
    c3 INT,
    UNIQUE (c1),
    UNIQUE (c2,c3)
)
----

exec-ddl
CREATE TABLE xyzbs
(
  x INT PRIMARY KEY,
  y INT,
  z INT NOT NULL,
  b BOOL NOT NULL,
  s TEXT,
  INDEX (y),
  INDEX (s)
)
----

exec-ddl
CREATE TABLE booleans (
		k INT PRIMARY KEY,
    a BOOL NOT NULL,
		b BOOL,
		c BOOL
)
----

# --------------------------------------------------
# EliminateGroupBy
# --------------------------------------------------

# Eliminate the GroupBy when the aggregate functions produce the same column as
# their input column.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,f,s") ])
    [
        (AggregationsItem (ConstAgg (Var "i")) (LookupColumn "i"))
        (AggregationsItem (ConstNotNullAgg (Var "f")) (LookupColumn "f"))
        (AggregationsItem (AnyNotNullAgg (Var "s")) (LookupColumn "s"))
    ]
    [ (GroupingCols "k") ]
)
----
scan a
 ├── columns: k:1!null i:2!null f:3 s:4!null
 ├── key: (1)
 └── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)

# Eliminate the GroupBy when the aggregate functions produce the same column as
# their input column. This tests for average and sum aggregator functions.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,f") ])
    [
        (AggregationsItem (Avg (Var "i")) (LookupColumn "i"))
        (AggregationsItem (Sum (Var "f")) (LookupColumn "f"))
    ]
    [ (GroupingCols "k") ]
)
----
scan a
 ├── columns: k:1!null i:2!null f:3
 ├── key: (1)
 └── fd: (1)-->(2-3), (2,3)~~>(1)

# Eliminate the GroupBy when the aggregate functions produce the same column as
# their input column. This tests for Max and Min aggregator functions.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,f") ])
    [
        (AggregationsItem (Max (Var "i")) (LookupColumn "i"))
        (AggregationsItem (Min (Var "f")) (LookupColumn "f"))
    ]
    [ (GroupingCols "k") ]
)
----
scan a
 ├── columns: k:1!null i:2!null f:3 s:4!null
 ├── key: (1)
 └── fd: (1)-->(2-3), (2,3)~~>(1)

# Eliminate the GroupBy when the aggregate functions produce the same column as
# their input column. This tests for Max and Min aggregator functions.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,s") ])
    [
        (AggregationsItem (XorAgg (Var "i")) (LookupColumn "i"))
        (AggregationsItem (ConcatAgg (Var "s")) (LookupColumn "s"))
        (AggregationsItem (StringAgg (Var "s")) (LookupColumn "s"))
    ]
    [ (GroupingCols "k") ]
)
----
scan a
 ├── columns: k:1!null i:2!null f:3 s:4!null
 ├── key: (1)
 └── fd: (1)-->(2-3), (2,3)~~>(1)

# Eliminate the GroupBy when the aggregate functions functions produce
# the same column as their input column. This tests for bool-and and bool-or
# aggregator functions.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "booleans") (Cols "k,a,b")])
		[
		    (AggregationsItem (BoolAnd (Var "a")) (LookupColumn "a"))
		    (AggregationsItem (BoolOr (Var "b")) (LookupColumn "b"))
		]
		[ (GroupingCols "k")]
)
----
scan booleans
 ├── columns: k:1!null a:2!null b:3
 ├── key: (1)
 ├── fd: (1)-->(2-3)

# Eliminate the GroupBy when the aggregate functions produce the same column as
# their input column and produce a new column. This tests for
# bitwise-and, bitwise-or, and sum integer aggregator functions.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i") ])
    [
        (AggregationsItem (BitAndAgg (Var "i")) (LookupColumn "i_bitAnd"))
        (AggregationsItem (BitOrAgg (Var "i")) (NewColumn "i_bitOr" "int"))
        (AggregationsItem (SumInt (Var "i")) (NewColumn "i_sumInt" "int"))
    ]
    [ (GroupingCols "k") ]
)
----
project
 ├── columns: i_bitAnd:8!null i_bitOr:9 i_sumInt:10!null k:1!null
 ├── key: (1)
 ├── fd: (1)-->(8-10)
 ├── scan a
 │    ├── columns: k:1!null i:2!null
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      ├── i:2 [as=i_bitAnd:8, outer=(2)]
      ├── f:3 [as=i_bitOr:9, outer=(3)]
      └── s:4 [as=i_sumInt:10, outer=(4)]



# Eliminate the GroupBy when the aggregate functions produce a new column.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,f,s") ])
    [
        (AggregationsItem (ConstAgg (Var "i")) (NewColumn "i_agg" "int"))
        (AggregationsItem (ConstNotNullAgg (Var "f")) (NewColumn "f_agg" "float"))
        (AggregationsItem (AnyNotNullAgg (Var "s")) (NewColumn "s_agg" "string"))
    ]
    [ (GroupingCols "k") ]
)
----
project
 ├── columns: i_agg:8!null f_agg:9 s_agg:10!null k:1!null
 ├── key: (1)
 ├── fd: (1)-->(8-10), (8,10)-->(1,9), (8,9)~~>(1,10)
 ├── scan a
 │    ├── columns: k:1!null i:2!null f:3 s:4!null
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)
 └── projections
      ├── i:2 [as=i_agg:8, outer=(2)]
      ├── f:3 [as=f_agg:9, outer=(3)]
      └── s:4 [as=s_agg:10, outer=(4)]

# Eliminate the GroupBy when there is a compound key.
exprnorm expect=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "i,f,s,j") ])
    [
        (AggregationsItem (ConstAgg (Var "f")) (LookupColumn "f"))
        (AggregationsItem (ConstNotNullAgg (Var "j")) (NewColumn "j_agg" "json"))
    ]
    [ (GroupingCols "i,s") ]
)
----
project
 ├── columns: j_agg:8 i:2!null f:3 s:4!null
 ├── key: (2,4)
 ├── fd: (2,4)-->(3,8), (2,3)~~>(4,8)
 ├── scan a
 │    ├── columns: i:2!null f:3 s:4!null j:5
 │    ├── key: (2,4)
 │    └── fd: (2,4)-->(3,5), (2,3)~~>(4,5)
 └── projections
      └── j:5 [as=j_agg:8, outer=(5)]

# Eliminate the GroupBy when there is a compound key.
exprnorm expect=EliminateGroupBy
(GroupBy
		(Scan [ (Table "a") (Cols "i,f,s,j") ])
		[
				(AggregationsItem (Avg (Var "f")) (LookupColumn "f"))
				(AggregationsItem (Sum (Var "i")) (NewColumn "i_sum" "int"))
				(AggregationsItem (StringAgg (Var "s")) (NewColumn "s_agg" "string"))
		]
		[ (GroupingCols "i,f") ]
)
----
project
 ├── columns: s_agg:8 i:2!null f:3 s:4!null
 ├── key: (2,4)
 ├── fd: (2,4)-->(3,8), (2,3)~~>(4,8)
 ├── scan a
 │    ├── columns: i:2!null f:3 s:4!null j:5
 │    ├── key: (2,4)
 │    └── fd: (2,4)-->(3,5), (2,3)~~>(4,5)
 └── projections
			└── j:5 [as=j_agg:8, outer=(5)]

# Eliminate unnecessary GroupBy generated during join decorrelation.
norm expect=EliminateGroupBy
SELECT CASE WHEN EXISTS (
    SELECT 1 FROM a WHERE k = x AND i = 1
) THEN 'Y' ELSE 'N' END
FROM xy
WHERE y = 2
----
project
 ├── columns: case:14!null
 ├── left-join (hash)
 │    ├── columns: x:1!null y:2!null k:5 i:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(5,6)
 │    ├── select
 │    │    ├── columns: x:1!null y:2!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null y:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    └── filters
 │    │         └── y:2 = 2 [outer=(2), constraints=(/2: [/2 - /2]; tight), fd=()-->(2)]
 │    ├── select
 │    │    ├── columns: k:5!null i:6!null
 │    │    ├── key: (5)
 │    │    ├── fd: ()-->(6)
 │    │    ├── scan a
 │    │    │    ├── columns: k:5!null i:6!null
 │    │    │    ├── key: (5)
 │    │    │    └── fd: (5)-->(6)
 │    │    └── filters
 │    │         └── i:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
 │    └── filters
 │         └── k:5 = x:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── projections
      └── CASE WHEN k:5 IS NOT NULL THEN 'Y' ELSE 'N' END [as=case:14, outer=(5)]

# Don't eliminate the GroupBy if there is an aggregate function other than
# ConstAgg, ConstNotNullAgg, or AnyNotNullAgg.
exprnorm expect-not=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "k,i,f,s") ])
    [
        (AggregationsItem (Sum (Var "i")) (NewColumn "sum" "int"))
        (AggregationsItem (ConstNotNullAgg (Var "f")) (NewColumn "f_agg" "float"))
        (AggregationsItem (AnyNotNullAgg (Var "s")) (NewColumn "s_agg" "string"))
    ]
    [ (GroupingCols "k") ]
)
----
group-by (hash)
 ├── columns: k:1!null sum:8!null f_agg:9 s_agg:10!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(8-10)
 ├── scan a
 │    ├── columns: k:1!null i:2!null f:3 s:4!null
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)
 └── aggregations
      ├── sum [as=sum:8, outer=(2)]
      │    └── i:2
      ├── const-not-null-agg [as=f_agg:9, outer=(3)]
      │    └── f:3
      └── any-not-null-agg [as=s_agg:10, outer=(4)]
           └── s:4

# Don't eliminate the GroupBy if the grouping columns do not form a key in the
# input.
exprnorm expect-not=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "i,f,s") ])
    [
        (AggregationsItem (ConstNotNullAgg (Var "f")) (NewColumn "f_agg" "float"))
        (AggregationsItem (AnyNotNullAgg (Var "s")) (NewColumn "s_agg" "string"))
    ]
    [ (GroupingCols "i") ]
)
----
group-by (hash)
 ├── columns: i:2!null f_agg:8 s_agg:9!null
 ├── grouping columns: i:2!null
 ├── key: (2)
 ├── fd: (2)-->(8,9)
 ├── scan a
 │    ├── columns: i:2!null f:3 s:4!null
 │    ├── key: (2,4)
 │    └── fd: (2,4)-->(3), (2,3)~~>(4)
 └── aggregations
      ├── const-not-null-agg [as=f_agg:8, outer=(3)]
      │    └── f:3
      └── any-not-null-agg [as=s_agg:9, outer=(4)]
           └── s:4

# Don't eliminate the GroupBy if the grouping columns form a lax key.
exprnorm expect-not=EliminateGroupBy
(GroupBy
    (Scan [ (Table "a") (Cols "i,f,s,j") ])
    [
        (AggregationsItem (ConstAgg (Var "s")) (LookupColumn "s"))
        (AggregationsItem (ConstNotNullAgg (Var "j")) (NewColumn "j_agg" "json"))
    ]
    [ (GroupingCols "i,f") ]
)
----
group-by (hash)
 ├── columns: i:2!null f:3 s:4!null j_agg:8
 ├── grouping columns: i:2!null f:3
 ├── key: (2,4)
 ├── fd: (2,4)-->(3,8), (2,3)-->(4,8)
 ├── scan a
 │    ├── columns: i:2!null f:3 s:4!null j:5
 │    ├── key: (2,4)
 │    └── fd: (2,4)-->(3,5), (2,3)~~>(4,5)
 └── aggregations
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-not-null-agg [as=j_agg:8, outer=(5)]
           └── j:5

